/*
  File autogenerated by gengetopt version 2.22.6
  generated with the following command:
  gengetopt -C --no-help --no-version --unamed-opts=SUBNETS -i
  /Users/dadrian/src/zmap/src/zitopt.ggo -F /Users/dadrian/src/zmap/src/zitopt

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void)(X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

#include "/Users/dadrian/src/zmap/src/zitopt.h"

const char *gengetopt_args_info_purpose =
    "A tool for iterating over the IPv4 space";

const char *gengetopt_args_info_usage =
    "Usage: ziterate [OPTIONS]... [SUBNETS]...";

const char *gengetopt_args_info_versiontext = "";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
    "Basic arguments:",
    "  -b, --blacklist-file=STRING   File of subnets to exclude, in CIDR notation,\n                                  one-per line.",
    "  -w, --whitelist-file=STRING   File of subnets to include, in CIDR notation,\n                                  one-per line.",
    "  -l, --log-file=STRING         File to log to",
    "  -v, --verbosity=INT           Set log level verbosity (0-5, default 3)\n                                  (default=`3')",
    "      --ignore-blacklist-errors Ignore invalid entires in the\n                                  blacklist/whitelist (default false)",
    "  -e, --seed=n                  Seed used to select address permutation",
    "  -n, --max-targets=n           Cap number of IPs to generate (as a number or a\n                                  percentage of the address space)",
    "      --disable-syslog          Disables logging messages to syslog",
    "\nSharding:",
    "      --shards=N                total number of shards  (default=`1')",
    "      --shard=n                 shard this scan is targeting (0 indexed)\n                                  (default=`0')",
    "\nAdditional options:",
    "  -h, --help                    Print help and exit",
    "  -V, --version                 Print version and exit",
    "\nExamples:\n    ziterate (iterate over all public IPv4 addresses)\n    ziterate -b exclusions 10.0.0.0/8 (iterate all IPs in 10./8 except those in\nblacklist)\n",
    0};

typedef enum {
	ARG_NO,
	ARG_STRING,
	ARG_INT,
	ARG_LONGLONG
} cmdline_parser_arg_type;

static void clear_given(struct gengetopt_args_info *args_info);
static void clear_args(struct gengetopt_args_info *args_info);

static int cmdline_parser_internal(int argc, char **argv,
				   struct gengetopt_args_info *args_info,
				   struct cmdline_parser_params *params,
				   const char *additional_error);

struct line_list {
	char *string_arg;
	struct line_list *next;
};

static struct line_list *cmd_line_list = 0;
static struct line_list *cmd_line_list_tmp = 0;

static void free_cmd_list(void)
{
	/* free the list of a previous call */
	if (cmd_line_list) {
		while (cmd_line_list) {
			cmd_line_list_tmp = cmd_line_list;
			cmd_line_list = cmd_line_list->next;
			free(cmd_line_list_tmp->string_arg);
			free(cmd_line_list_tmp);
		}
	}
}

static char *gengetopt_strdup(const char *s);

static void clear_given(struct gengetopt_args_info *args_info)
{
	args_info->blacklist_file_given = 0;
	args_info->whitelist_file_given = 0;
	args_info->log_file_given = 0;
	args_info->verbosity_given = 0;
	args_info->ignore_blacklist_errors_given = 0;
	args_info->seed_given = 0;
	args_info->max_targets_given = 0;
	args_info->disable_syslog_given = 0;
	args_info->shards_given = 0;
	args_info->shard_given = 0;
	args_info->help_given = 0;
	args_info->version_given = 0;
}

static void clear_args(struct gengetopt_args_info *args_info)
{
	FIX_UNUSED(args_info);
	args_info->blacklist_file_arg = NULL;
	args_info->blacklist_file_orig = NULL;
	args_info->whitelist_file_arg = NULL;
	args_info->whitelist_file_orig = NULL;
	args_info->log_file_arg = NULL;
	args_info->log_file_orig = NULL;
	args_info->verbosity_arg = 3;
	args_info->verbosity_orig = NULL;
	args_info->seed_orig = NULL;
	args_info->max_targets_arg = NULL;
	args_info->max_targets_orig = NULL;
	args_info->shards_arg = 1;
	args_info->shards_orig = NULL;
	args_info->shard_arg = 0;
	args_info->shard_orig = NULL;
}

static void init_args_info(struct gengetopt_args_info *args_info)
{

	args_info->blacklist_file_help = gengetopt_args_info_help[1];
	args_info->whitelist_file_help = gengetopt_args_info_help[2];
	args_info->log_file_help = gengetopt_args_info_help[3];
	args_info->verbosity_help = gengetopt_args_info_help[4];
	args_info->ignore_blacklist_errors_help = gengetopt_args_info_help[5];
	args_info->seed_help = gengetopt_args_info_help[6];
	args_info->max_targets_help = gengetopt_args_info_help[7];
	args_info->disable_syslog_help = gengetopt_args_info_help[8];
	args_info->shards_help = gengetopt_args_info_help[10];
	args_info->shard_help = gengetopt_args_info_help[11];
	args_info->help_help = gengetopt_args_info_help[13];
	args_info->version_help = gengetopt_args_info_help[14];
}

void cmdline_parser_print_version(void)
{
	printf("%s %s\n",
	       (strlen(CMDLINE_PARSER_PACKAGE_NAME)
		    ? CMDLINE_PARSER_PACKAGE_NAME
		    : CMDLINE_PARSER_PACKAGE),
	       CMDLINE_PARSER_VERSION);

	if (strlen(gengetopt_args_info_versiontext) > 0)
		printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void)
{
	cmdline_parser_print_version();

	if (strlen(gengetopt_args_info_purpose) > 0)
		printf("\n%s\n", gengetopt_args_info_purpose);

	if (strlen(gengetopt_args_info_usage) > 0)
		printf("\n%s\n", gengetopt_args_info_usage);

	printf("\n");

	if (strlen(gengetopt_args_info_description) > 0)
		printf("%s\n\n", gengetopt_args_info_description);
}

void cmdline_parser_print_help(void)
{
	int i = 0;
	print_help_common();
	while (gengetopt_args_info_help[i])
		printf("%s\n", gengetopt_args_info_help[i++]);
}

void cmdline_parser_init(struct gengetopt_args_info *args_info)
{
	clear_given(args_info);
	clear_args(args_info);
	init_args_info(args_info);

	args_info->inputs = 0;
	args_info->inputs_num = 0;
}

void cmdline_parser_params_init(struct cmdline_parser_params *params)
{
	if (params) {
		params->override = 0;
		params->initialize = 1;
		params->check_required = 1;
		params->check_ambiguity = 0;
		params->print_errors = 1;
	}
}

struct cmdline_parser_params *cmdline_parser_params_create(void)
{
	struct cmdline_parser_params *params =
	    (struct cmdline_parser_params *)malloc(
		sizeof(struct cmdline_parser_params));
	cmdline_parser_params_init(params);
	return params;
}

static void free_string_field(char **s)
{
	if (*s) {
		free(*s);
		*s = 0;
	}
}

static void cmdline_parser_release(struct gengetopt_args_info *args_info)
{
	unsigned int i;
	free_string_field(&(args_info->blacklist_file_arg));
	free_string_field(&(args_info->blacklist_file_orig));
	free_string_field(&(args_info->whitelist_file_arg));
	free_string_field(&(args_info->whitelist_file_orig));
	free_string_field(&(args_info->log_file_arg));
	free_string_field(&(args_info->log_file_orig));
	free_string_field(&(args_info->verbosity_orig));
	free_string_field(&(args_info->seed_orig));
	free_string_field(&(args_info->max_targets_arg));
	free_string_field(&(args_info->max_targets_orig));
	free_string_field(&(args_info->shards_orig));
	free_string_field(&(args_info->shard_orig));

	for (i = 0; i < args_info->inputs_num; ++i)
		free(args_info->inputs[i]);

	if (args_info->inputs_num)
		free(args_info->inputs);

	clear_given(args_info);
}

static void write_into_file(FILE *outfile, const char *opt, const char *arg,
			    const char *values[])
{
	FIX_UNUSED(values);
	if (arg) {
		fprintf(outfile, "%s=\"%s\"\n", opt, arg);
	} else {
		fprintf(outfile, "%s\n", opt);
	}
}

int cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
	int i = 0;

	if (!outfile) {
		fprintf(stderr, "%s: cannot dump options to stream\n",
			CMDLINE_PARSER_PACKAGE);
		return EXIT_FAILURE;
	}

	if (args_info->blacklist_file_given)
		write_into_file(outfile, "blacklist-file",
				args_info->blacklist_file_orig, 0);
	if (args_info->whitelist_file_given)
		write_into_file(outfile, "whitelist-file",
				args_info->whitelist_file_orig, 0);
	if (args_info->log_file_given)
		write_into_file(outfile, "log-file", args_info->log_file_orig,
				0);
	if (args_info->verbosity_given)
		write_into_file(outfile, "verbosity", args_info->verbosity_orig,
				0);
	if (args_info->ignore_blacklist_errors_given)
		write_into_file(outfile, "ignore-blacklist-errors", 0, 0);
	if (args_info->seed_given)
		write_into_file(outfile, "seed", args_info->seed_orig, 0);
	if (args_info->max_targets_given)
		write_into_file(outfile, "max-targets",
				args_info->max_targets_orig, 0);
	if (args_info->disable_syslog_given)
		write_into_file(outfile, "disable-syslog", 0, 0);
	if (args_info->shards_given)
		write_into_file(outfile, "shards", args_info->shards_orig, 0);
	if (args_info->shard_given)
		write_into_file(outfile, "shard", args_info->shard_orig, 0);
	if (args_info->help_given)
		write_into_file(outfile, "help", 0, 0);
	if (args_info->version_given)
		write_into_file(outfile, "version", 0, 0);

	i = EXIT_SUCCESS;
	return i;
}

int cmdline_parser_file_save(const char *filename,
			     struct gengetopt_args_info *args_info)
{
	FILE *outfile;
	int i = 0;

	outfile = fopen(filename, "w");

	if (!outfile) {
		fprintf(stderr, "%s: cannot open file for writing: %s\n",
			CMDLINE_PARSER_PACKAGE, filename);
		return EXIT_FAILURE;
	}

	i = cmdline_parser_dump(outfile, args_info);
	fclose(outfile);

	return i;
}

void cmdline_parser_free(struct gengetopt_args_info *args_info)
{
	cmdline_parser_release(args_info);
}

/** @brief replacement of strdup, which is not standard */
char *gengetopt_strdup(const char *s)
{
	char *result = 0;
	if (!s)
		return result;

	result = (char *)malloc(strlen(s) + 1);
	if (result == (char *)0)
		return (char *)0;
	strcpy(result, s);
	return result;
}

int cmdline_parser(int argc, char **argv, struct gengetopt_args_info *args_info)
{
	return cmdline_parser2(argc, argv, args_info, 0, 1, 1);
}

int cmdline_parser_ext(int argc, char **argv,
		       struct gengetopt_args_info *args_info,
		       struct cmdline_parser_params *params)
{
	int result;
	result = cmdline_parser_internal(argc, argv, args_info, params, 0);

	if (result == EXIT_FAILURE) {
		cmdline_parser_free(args_info);
		exit(EXIT_FAILURE);
	}

	return result;
}

int cmdline_parser2(int argc, char **argv,
		    struct gengetopt_args_info *args_info, int override,
		    int initialize, int check_required)
{
	int result;
	struct cmdline_parser_params params;

	params.override = override;
	params.initialize = initialize;
	params.check_required = check_required;
	params.check_ambiguity = 0;
	params.print_errors = 1;

	result = cmdline_parser_internal(argc, argv, args_info, &params, 0);

	if (result == EXIT_FAILURE) {
		cmdline_parser_free(args_info);
		exit(EXIT_FAILURE);
	}

	return result;
}

int cmdline_parser_required(struct gengetopt_args_info *args_info,
			    const char *prog_name)
{
	FIX_UNUSED(args_info);
	FIX_UNUSED(prog_name);
	return EXIT_SUCCESS;
}

static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed
 * values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static int update_arg(void *field, char **orig_field, unsigned int *field_given,
		      unsigned int *prev_given, char *value,
		      const char *possible_values[], const char *default_value,
		      cmdline_parser_arg_type arg_type, int check_ambiguity,
		      int override, int no_free, int multiple_option,
		      const char *long_opt, char short_opt,
		      const char *additional_error)
{
	char *stop_char = 0;
	const char *val = value;
	int found;
	char **string_field;
	FIX_UNUSED(field);

	stop_char = 0;
	found = 0;

	if (!multiple_option && prev_given &&
	    (*prev_given || (check_ambiguity && *field_given))) {
		if (short_opt != '-')
			fprintf(
			    stderr,
			    "%s: `--%s' (`-%c') option given more than once%s\n",
			    package_name, long_opt, short_opt,
			    (additional_error ? additional_error : ""));
		else
			fprintf(stderr,
				"%s: `--%s' option given more than once%s\n",
				package_name, long_opt,
				(additional_error ? additional_error : ""));
		return 1; /* failure */
	}

	FIX_UNUSED(default_value);

	if (field_given && *field_given && !override)
		return 0;
	if (prev_given)
		(*prev_given)++;
	if (field_given)
		(*field_given)++;
	if (possible_values)
		val = possible_values[found];

	switch (arg_type) {
	case ARG_INT:
		if (val)
			*((int *)field) = strtol(val, &stop_char, 0);
		break;
	case ARG_LONGLONG:
#if defined(HAVE_LONG_LONG) || defined(HAVE_LONG_LONG_INT)
		if (val)
			*((long long int *)field) =
			    (long long int)strtoll(val, &stop_char, 0);
#else
		if (val)
			*((long *)field) = (long)strtol(val, &stop_char, 0);
#endif
		break;
	case ARG_STRING:
		if (val) {
			string_field = (char **)field;
			if (!no_free && *string_field)
				free(*string_field); /* free previous string */
			*string_field = gengetopt_strdup(val);
		}
		break;
	default:
		break;
	};

	/* check numeric conversion */
	switch (arg_type) {
	case ARG_INT:
	case ARG_LONGLONG:
		if (val && !(stop_char && *stop_char == '\0')) {
			fprintf(stderr, "%s: invalid numeric value: %s\n",
				package_name, val);
			return 1; /* failure */
		}
		break;
	default:;
	};

	/* store the original value */
	switch (arg_type) {
	case ARG_NO:
		break;
	default:
		if (value && orig_field) {
			if (no_free) {
				*orig_field = value;
			} else {
				if (*orig_field)
					free(*orig_field); /* free previous
							      string */
				*orig_field = gengetopt_strdup(value);
			}
		}
	};

	return 0; /* OK */
}

int cmdline_parser_internal(int argc, char **argv,
			    struct gengetopt_args_info *args_info,
			    struct cmdline_parser_params *params,
			    const char *additional_error)
{
	int c; /* Character of the parsed option.  */

	int error_occurred = 0;
	struct gengetopt_args_info local_args_info;

	int override;
	int initialize;
	int check_required;
	int check_ambiguity;

	package_name = argv[0];

	override = params->override;
	initialize = params->initialize;
	check_required = params->check_required;
	check_ambiguity = params->check_ambiguity;

	if (initialize)
		cmdline_parser_init(args_info);

	cmdline_parser_init(&local_args_info);

	optarg = 0;
	optind = 0;
	opterr = params->print_errors;
	optopt = '?';

	while (1) {
		int option_index = 0;

		static struct option long_options[] = {
		    {"blacklist-file", 1, NULL, 'b'},
		    {"whitelist-file", 1, NULL, 'w'},
		    {"log-file", 1, NULL, 'l'},
		    {"verbosity", 1, NULL, 'v'},
		    {"ignore-blacklist-errors", 0, NULL, 0},
		    {"seed", 1, NULL, 'e'},
		    {"max-targets", 1, NULL, 'n'},
		    {"disable-syslog", 0, NULL, 0},
		    {"shards", 1, NULL, 0},
		    {"shard", 1, NULL, 0},
		    {"help", 0, NULL, 'h'},
		    {"version", 0, NULL, 'V'},
		    {0, 0, 0, 0}};

		c = getopt_long(argc, argv, "b:w:l:v:e:n:hV", long_options,
				&option_index);

		if (c == -1)
			break; /* Exit from `while (1)' loop.  */

		switch (c) {
		case 'b': /* File of subnets to exclude, in CIDR notation,
			     one-per line..  */

			if (update_arg((void *)&(args_info->blacklist_file_arg),
				       &(args_info->blacklist_file_orig),
				       &(args_info->blacklist_file_given),
				       &(local_args_info.blacklist_file_given),
				       optarg, 0, 0, ARG_STRING,
				       check_ambiguity, override, 0, 0,
				       "blacklist-file", 'b', additional_error))
				goto failure;

			break;
		case 'w': /* File of subnets to include, in CIDR notation,
			     one-per line..  */

			if (update_arg((void *)&(args_info->whitelist_file_arg),
				       &(args_info->whitelist_file_orig),
				       &(args_info->whitelist_file_given),
				       &(local_args_info.whitelist_file_given),
				       optarg, 0, 0, ARG_STRING,
				       check_ambiguity, override, 0, 0,
				       "whitelist-file", 'w', additional_error))
				goto failure;

			break;
		case 'l': /* File to log to.  */

			if (update_arg((void *)&(args_info->log_file_arg),
				       &(args_info->log_file_orig),
				       &(args_info->log_file_given),
				       &(local_args_info.log_file_given),
				       optarg, 0, 0, ARG_STRING,
				       check_ambiguity, override, 0, 0,
				       "log-file", 'l', additional_error))
				goto failure;

			break;
		case 'v': /* Set log level verbosity (0-5, default 3).  */

			if (update_arg((void *)&(args_info->verbosity_arg),
				       &(args_info->verbosity_orig),
				       &(args_info->verbosity_given),
				       &(local_args_info.verbosity_given),
				       optarg, 0, "3", ARG_INT, check_ambiguity,
				       override, 0, 0, "verbosity", 'v',
				       additional_error))
				goto failure;

			break;
		case 'e': /* Seed used to select address permutation.  */

			if (update_arg((void *)&(args_info->seed_arg),
				       &(args_info->seed_orig),
				       &(args_info->seed_given),
				       &(local_args_info.seed_given), optarg, 0,
				       0, ARG_LONGLONG, check_ambiguity,
				       override, 0, 0, "seed", 'e',
				       additional_error))
				goto failure;

			break;
		case 'n': /* Cap number of IPs to generate (as a number or a
			     percentage of the address space).  */

			if (update_arg((void *)&(args_info->max_targets_arg),
				       &(args_info->max_targets_orig),
				       &(args_info->max_targets_given),
				       &(local_args_info.max_targets_given),
				       optarg, 0, 0, ARG_STRING,
				       check_ambiguity, override, 0, 0,
				       "max-targets", 'n', additional_error))
				goto failure;

			break;
		case 'h': /* Print help and exit.  */

			if (update_arg(0, 0, &(args_info->help_given),
				       &(local_args_info.help_given), optarg, 0,
				       0, ARG_NO, check_ambiguity, override, 0,
				       0, "help", 'h', additional_error))
				goto failure;

			break;
		case 'V': /* Print version and exit.  */

			if (update_arg(0, 0, &(args_info->version_given),
				       &(local_args_info.version_given), optarg,
				       0, 0, ARG_NO, check_ambiguity, override,
				       0, 0, "version", 'V', additional_error))
				goto failure;

			break;

		case 0: /* Long option with no short option */
			/* Ignore invalid entires in the blacklist/whitelist
			 * (default false).  */
			if (strcmp(long_options[option_index].name,
				   "ignore-blacklist-errors") == 0) {

				if (update_arg(
					0, 0,
					&(args_info
					      ->ignore_blacklist_errors_given),
					&(local_args_info
					      .ignore_blacklist_errors_given),
					optarg, 0, 0, ARG_NO, check_ambiguity,
					override, 0, 0,
					"ignore-blacklist-errors", '-',
					additional_error))
					goto failure;

			}
			/* Disables logging messages to syslog.  */
			else if (strcmp(long_options[option_index].name,
					"disable-syslog") == 0) {

				if (update_arg(
					0, 0,
					&(args_info->disable_syslog_given),
					&(local_args_info.disable_syslog_given),
					optarg, 0, 0, ARG_NO, check_ambiguity,
					override, 0, 0, "disable-syslog", '-',
					additional_error))
					goto failure;

			}
			/* total number of shards.  */
			else if (strcmp(long_options[option_index].name,
					"shards") == 0) {

				if (update_arg((void *)&(args_info->shards_arg),
					       &(args_info->shards_orig),
					       &(args_info->shards_given),
					       &(local_args_info.shards_given),
					       optarg, 0, "1", ARG_INT,
					       check_ambiguity, override, 0, 0,
					       "shards", '-', additional_error))
					goto failure;

			}
			/* shard this scan is targeting (0 indexed).  */
			else if (strcmp(long_options[option_index].name,
					"shard") == 0) {

				if (update_arg((void *)&(args_info->shard_arg),
					       &(args_info->shard_orig),
					       &(args_info->shard_given),
					       &(local_args_info.shard_given),
					       optarg, 0, "0", ARG_INT,
					       check_ambiguity, override, 0, 0,
					       "shard", '-', additional_error))
					goto failure;
			}

			break;
		case '?': /* Invalid option.  */
			/* `getopt_long' already printed an error message.  */
			goto failure;

		default: /* bug: option not considered.  */
			fprintf(stderr, "%s: option unknown: %c%s\n",
				CMDLINE_PARSER_PACKAGE, c,
				(additional_error ? additional_error : ""));
			abort();
		} /* switch */
	}	 /* while */

	cmdline_parser_release(&local_args_info);

	if (error_occurred)
		return (EXIT_FAILURE);

	if (optind < argc) {
		int i = 0;
		int found_prog_name = 0;
		/* whether program name, i.e., argv[0], is in the remaining args
		   (this may happen with some implementations of getopt,
		    but surely not with the one included by gengetopt) */

		i = optind;
		while (i < argc)
			if (argv[i++] == argv[0]) {
				found_prog_name = 1;
				break;
			}
		i = 0;

		args_info->inputs_num = argc - optind - found_prog_name;
		args_info->inputs =
		    (char **)(malloc((args_info->inputs_num) * sizeof(char *)));
		while (optind < argc)
			if (argv[optind++] != argv[0])
				args_info->inputs[i++] =
				    gengetopt_strdup(argv[optind - 1]);
	}

	return 0;

failure:

	cmdline_parser_release(&local_args_info);
	return (EXIT_FAILURE);
}

#ifndef CONFIG_FILE_LINE_SIZE
#define CONFIG_FILE_LINE_SIZE 2048
#endif
#define ADDITIONAL_ERROR " in configuration file "

#define CONFIG_FILE_LINE_BUFFER_SIZE (CONFIG_FILE_LINE_SIZE + 3)
/* 3 is for "--" and "=" */

static int _cmdline_parser_configfile(const char *filename, int *my_argc)
{
	FILE *file;
	char my_argv[CONFIG_FILE_LINE_BUFFER_SIZE + 1];
	char linebuf[CONFIG_FILE_LINE_SIZE];
	int line_num = 0;
	int result = 0, equal;
	char *fopt, *farg;
	char *str_index;
	size_t len, next_token;
	char delimiter;

	if ((file = fopen(filename, "r")) == 0) {
		fprintf(stderr, "%s: Error opening configuration file '%s'\n",
			CMDLINE_PARSER_PACKAGE, filename);
		return EXIT_FAILURE;
	}

	while ((fgets(linebuf, CONFIG_FILE_LINE_SIZE, file)) != 0) {
		++line_num;
		my_argv[0] = '\0';
		len = strlen(linebuf);
		if (len > (CONFIG_FILE_LINE_BUFFER_SIZE - 1)) {
			fprintf(
			    stderr,
			    "%s:%s:%d: Line too long in configuration file\n",
			    CMDLINE_PARSER_PACKAGE, filename, line_num);
			result = EXIT_FAILURE;
			break;
		}

		/* find first non-whitespace character in the line */
		next_token = strspn(linebuf, " \t\r\n");
		str_index = linebuf + next_token;

		if (str_index[0] == '\0' || str_index[0] == '#')
			continue; /* empty line or comment line is skipped */

		fopt = str_index;

		/* truncate fopt at the end of the first non-valid character */
		next_token = strcspn(fopt, " \t\r\n=");

		if (fopt[next_token] == '\0') /* the line is over */
		{
			farg = 0;
			equal = 0;
			goto noarg;
		}

		/* remember if equal sign is present */
		equal = (fopt[next_token] == '=');
		fopt[next_token++] = '\0';

		/* advance pointers to the next token after the end of fopt */
		next_token += strspn(fopt + next_token, " \t\r\n");

		/* check for the presence of equal sign, and if so, skip it */
		if (!equal)
			if ((equal = (fopt[next_token] == '='))) {
				next_token++;
				next_token +=
				    strspn(fopt + next_token, " \t\r\n");
			}
		str_index += next_token;

		/* find argument */
		farg = str_index;
		if (farg[0] == '\"' || farg[0] == '\'') { /* quoted argument */
			str_index = strchr(
			    ++farg, str_index[0]); /* skip opening quote */
			if (!str_index) {
				fprintf(
				    stderr,
				    "%s:%s:%d: unterminated string in configuration file\n",
				    CMDLINE_PARSER_PACKAGE, filename, line_num);
				result = EXIT_FAILURE;
				break;
			}
		} else { /* read up the remaining part up to a delimiter */
			next_token = strcspn(farg, " \t\r\n#\'\"");
			str_index += next_token;
		}

		/* truncate farg at the delimiter and store it for further check
		 */
		delimiter = *str_index, *str_index++ = '\0';

		/* everything but comment is illegal at the end of line */
		if (delimiter != '\0' && delimiter != '#') {
			str_index += strspn(str_index, " \t\r\n");
			if (*str_index != '\0' && *str_index != '#') {
				fprintf(
				    stderr,
				    "%s:%s:%d: malformed string in configuration file\n",
				    CMDLINE_PARSER_PACKAGE, filename, line_num);
				result = EXIT_FAILURE;
				break;
			}
		}

	noarg:
		if (!strcmp(fopt, "include")) {
			if (farg && *farg) {
				result =
				    _cmdline_parser_configfile(farg, my_argc);
			} else {
				fprintf(
				    stderr,
				    "%s:%s:%d: include requires a filename argument.\n",
				    CMDLINE_PARSER_PACKAGE, filename, line_num);
			}
			continue;
		}
		len = strlen(fopt);
		strcat(my_argv, len > 1 ? "--" : "-");
		strcat(my_argv, fopt);
		if (len > 1 && ((farg && *farg) || equal))
			strcat(my_argv, "=");
		if (farg && *farg)
			strcat(my_argv, farg);
		++(*my_argc);

		cmd_line_list_tmp =
		    (struct line_list *)malloc(sizeof(struct line_list));
		cmd_line_list_tmp->next = cmd_line_list;
		cmd_line_list = cmd_line_list_tmp;
		cmd_line_list->string_arg = gengetopt_strdup(my_argv);
	} /* while */

	if (file)
		fclose(file);
	return result;
}

int cmdline_parser_configfile(const char *filename,
			      struct gengetopt_args_info *args_info,
			      int override, int initialize, int check_required)
{
	struct cmdline_parser_params params;

	params.override = override;
	params.initialize = initialize;
	params.check_required = check_required;
	params.check_ambiguity = 0;
	params.print_errors = 1;

	return cmdline_parser_config_file(filename, args_info, &params);
}

int cmdline_parser_config_file(const char *filename,
			       struct gengetopt_args_info *args_info,
			       struct cmdline_parser_params *params)
{
	int i, result;
	int my_argc = 1;
	char **my_argv_arg;
	char *additional_error;

	/* store the program name */
	cmd_line_list_tmp =
	    (struct line_list *)malloc(sizeof(struct line_list));
	cmd_line_list_tmp->next = cmd_line_list;
	cmd_line_list = cmd_line_list_tmp;
	cmd_line_list->string_arg = gengetopt_strdup(CMDLINE_PARSER_PACKAGE);

	result = _cmdline_parser_configfile(filename, &my_argc);

	if (result != EXIT_FAILURE) {
		my_argv_arg = (char **)malloc((my_argc + 1) * sizeof(char *));
		cmd_line_list_tmp = cmd_line_list;

		for (i = my_argc - 1; i >= 0; --i) {
			my_argv_arg[i] = cmd_line_list_tmp->string_arg;
			cmd_line_list_tmp = cmd_line_list_tmp->next;
		}

		my_argv_arg[my_argc] = 0;

		additional_error = (char *)malloc(strlen(filename) +
						  strlen(ADDITIONAL_ERROR) + 1);
		strcpy(additional_error, ADDITIONAL_ERROR);
		strcat(additional_error, filename);
		result = cmdline_parser_internal(
		    my_argc, my_argv_arg, args_info, params, additional_error);

		free(additional_error);
		free(my_argv_arg);
	}

	free_cmd_list();
	if (result == EXIT_FAILURE) {
		cmdline_parser_free(args_info);
		exit(EXIT_FAILURE);
	}

	return result;
}
